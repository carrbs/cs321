/* *************************** 
 * Student: Benjamin Carr
 * carrbs@cs.pdx.edu
 *
 * proj3 (miniParser.jj)
 *
 *
 * ***************************/

PARSER_BEGIN(miniParser) 
package parser; 
import ast.*;
public class miniParser {}
PARSER_END(miniParser)

SKIP : /* WHITE SPACE */
{
  " "
  | "\t"
  | "\n"
  | "\r"
}

MORE : /* Comments */
{
 "//" : IN_SINGLE_LINE_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
 <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
 <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
 < ~[] >
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
 < BOOLEAN: "boolean" >
| < CLASS: "class" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FLOAT: "float" >
| < IF: "if" >
| < INT: "int" >
| < LENGTH: "length" >
| < MAIN: "main" >
| < NEW: "new" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < PRINT_LINE: "System.out.println" >
| < STATIC: "static" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < STRING: "String" >
}


TOKEN : /* IDs and Numbers */
{
  < #DIGIT: ["0"-"9"] > 
| < #LETTER: ["A"-"Z"] | ["a"-"z"] > 
| < ID: <LETTER> (<LETTER> | <DIGIT>)* > 
  {
        if (matchedToken.image.length() > 255)
            throw new TokenMgrError("Lexical error at line "
            + matchedToken.beginLine + ", column " + matchedToken.beginColumn + ".  Id length over 255", 0);
  }
| < INTVAL: (<DIGIT>)+ >
  {
        if (Long.valueOf(matchedToken.image) > 2147483647)
            throw new TokenMgrError("Lexical error at line "
            + matchedToken.beginLine + ", column " + matchedToken.beginColumn + ".  Integer value over 2^31-1", 0);
  }
| < REAL: (((<DIGIT>)* "." (<DIGIT>)+) ("f" | "F")) | (((<DIGIT>)+ "." (<DIGIT>)*) ("f" | "F")) >
}

TOKEN : /* Delimiters & Operators */ 
{
 < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COMMA: "," >
| < ASSIGNMENT: "=" >
| < SEMICOLON: ";" >
| < OR: "||" >
| < AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < PERIOD: "." >
| < NOT: "!" >
| < EQUAL: "==" >
| < NOT_EQUAL: "!=" >
| < LESS_THAN: "<" >
| < LESS_THAN_OR_EQUAL: "<=" >
| < GREATER_THAN: ">" >
| < GREATER_THAN_OR_EQUAL: ">=" >
}

TOKEN: /* String Literal */
{
 < STRING_LITERAL : "\"" ( ~["\r", "\n", "\""])* "\"" >
 { 
    if (matchedToken.image.length() > 257) 
        throw new TokenMgrError("Lexical error at line "
        + matchedToken.beginLine + ", column " + matchedToken.beginColumn + ". String length over 255", 0);
 }
}

// Program    -> ClassDecl {ClassDecl}
Program Program() :
{ ClassDecl c; ClassDeclList cl = new ClassDeclList(); }
{
    c = ClassDecl() { cl.add(c); } ( c=ClassDecl() { cl.add(c); })* <EOF>
    { return new Program(cl); }
}

// ClassDecl  -> "class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
ClassDecl ClassDecl() :
{   Token tkn; Id ci; Id pi = null; 
    VarDecl v;
    MethodDecl m;
    VarDeclList avl = new VarDeclList(); 
    MethodDeclList aml = new MethodDeclList();
}
{
    <CLASS> tkn=<ID>{ ci = new Id(tkn.toString()); }
    [ <EXTENDS> <ID>{ pi = new Id(tkn.toString()); } ]
    <LBRACE> ( v = VarDecl() { avl.add(v); } )* 
    ( m = MethodDecl() { aml.add(m); })* <RBRACE>
    { return new ClassDecl(ci, pi, avl, aml); }
}

// MethodDecl -> "public" ( (Type | "void") <ID> '(' [Formals] ')' 
//                      | "static" "void" "main" '(' "String" '[' ']' <ID> ')' )
//                                       '{' {VarDecl} {Statement} '}'
MethodDecl MethodDecl() :
{
    Type at; Token tkn; Id i; 
    FormalList afl = null; 
    VarDecl v; VarDeclList avl;
    Stmt s; StmtList asl;
}
{
    <PUBLIC> ( (at = Type() | <VOID>) tkn=<ID>{ i = new Id(tkn.toString()); }
    <LPAREN> [afl = Formals()] <RPAREN> 
    |
    <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACKET> <RBRACKET> <ID>
    <RPAREN>)
    <LBRACE> ( LOOKAHEAD(2) v = VarDecl() { avl.add(v); } )* ( s = Statement() {
    asl.add(s) )* <RBRACE>
    { return new MethodDecl(at, i, afl, avl, asl); }
}

// Formals    -> Type <ID> {"," Type <ID>}
FormalList Formals() : 
{FormalList afl = new FormalList(); Formal f; Type t; Id i; Token tkn; }
{
    t = Type() tkn=<ID>{ i = new Id(tkn.toString()); f = new Formal(t, i);
    afl.add(f); } 
    ( <COMMA> t = Type() tkn=<ID>{ i = new Id(tkn.toString()); f = new Formal(t,
    i); afl.add(f); } )*
    { return afl; }

}

// VarDecl    -> Type <ID> ["=" InitExpr] ";"
VarDecl VarDecl() : 
{ Type t; Token tkn; Id i; Exp e;}
{
    t = Type() tkn=<ID>{ i = new Id(tkn.toString()); } 
    [ <ASSIGNMENT> e = InitExpr() ] <SEMICOLON>
    { return new VarDecl(t, i, e); }
}

// Type       -> BasicType ["[" "]"] | <ID>
Type Type() :
{ Type t; boolean isArray = false; Token t; Id i;}
{
    t = BasicType() [<LBRACKET> <RBRACKET> { isArray = true;}] 
    {
        if (isArray) 
            return new ArrayType(t); 
        else return t;
    }
|
    tkn=<ID>{ i = new(tkn.toString()); return new ObjType(i); }
}

// BasicType  -> "int" | "float" | "boolean"
Type BasicType() :
{}
{
    <INT>
    { return new BasicType(BasicType.Int); }
|
    <FLOAT>
    { return new BasicType(BasicType.Float); }
|
    <BOOLEAN>
    { return new BasicType(BasicType.Bool); }
}

// Statement  -> "{" {Statement} "}"
//            |  Lvalue ('=' InitExpr | '(' [Args] ')') ';'
//            |  "if" "(" Expr ")" Statement ["else" Statement]
//            |  "while" "(" Expr ")" Statement
//            |  "System.out.println" "(" [Expr | <STRVAL>] ")" ";"
//            |  "return" [Expr] ";"
Stmt Statement() :
{ boolean isAssign = false; Exp ex = null; StmtList asl; Stmt s1 = null, s2 = null; StrVal sv;}
{
    <LBRACE> ( s1 = Statement(){ asl.add(s1); } )* <RBRACE>
    { return new Block(asl); }
|
    Lvalue() (<ASSIGNMENT> InitExpr(){isAssign = true;} 
        | <LPAREN> [Args()] <RPAREN>) <SEMICOLON>
    {
        if (isAssign)
            return new Assign(ass);
        else
            return new CallStmt;
    }
|
    <IF> <LPAREN> ex = Expr() <RPAREN> s1 = Statement() 
    [LOOKAHEAD(1) <ELSE> s2 = Statement()]
    { return new If(ex, s1, s2); }
|
    <WHILE> <LPAREN> ex = Expr() <RPAREN> s1 = Statement()
    { return new While(ex, s1); }
|
    <PRINT_LINE> <LPAREN> [ex = Expr() | tkn=<STRING_LITERAL>
    { sv = new StrVal(tkn.toString().replace("\"", "")); } ] <RPAREN> <SEMICOLON>
    {
        if (ex == null)
            return new Print(sv);
        else return new Print(ex); 
    }
|
    <RETURN> [ ex = Expr() ] <SEMICOLON>
    { return new Return(ex); }
}

// Args       -> Expr {"," Expr}
void Args() :
{}
{
    Expr() ( <COMMA> Expr() )*
}

// InitExpr   -> "new" ( BasicType '[' <INTVAL> ']' | <ID> '(' [Args] ')' )
//            |  Expr
void InitExpr() :
{}
{
    <NEW> ( BasicType() <LBRACKET> <INTVAL> <RBRACKET> 
    |
    <ID> <LPAREN> [Args()] <RPAREN>)
|
    Expr()
}

// Expr         -> AndExpr OrTail
void Expr() :
{}
{
    AndExpr() OrTail() 
}

// OrTail       -> [ "||"  AndExpr OrTail ]
void OrTail() :
{}
{
    [ <OR> AndExpr() OrTail() ]
}

// AndExpr    -> RelExpr AndTail
void AndExpr() :
{}
{
    RelExpr() AndTail() 
}

// AndTail()    -> [ "&&" RelExpr AndTail ]
void AndTail() :
{}
{
    [ <AND> RelExpr() AndTail() ]
}

// RelExpr    -> ArithExpr [RelOp ArithExpr]
void RelExpr() :
{}
{
    ArithExpr() [ Relop() ArithExpr() ]
}

// ArithExpr -> Term ArithTail
void ArithExpr() :
{}
{
    Term() ArithTail()
}

// ArithTail    -> [ PlusMinusOp Term ArithTail ]
void ArithTail() :
{}
{
    [ PlusMinusOp()  Term() ArithTail() ]
}

// PlusMinusOp      -> "+" | "-"
void PlusMinusOp() :
{}
{
    <PLUS>
|
    <MINUS>
}

// Term         -> Factor TermTail
void Term() :
{}
{
    Factor() TermTail()
}

// TermTail -> [ MultDivideOp Factor TermTail ]
void TermTail() :
{}
{
    [ MultDivideOp()  Factor() TermTail() ]
}

// MultDivideOp     -> "*" | "/"
void MultDivideOp() :
{}
{
    <MULTIPLY>
|
    <DIVIDE>
}

// Factor     -> Unop Factor
//            |  "(" Expr ")"
//            |  Lvalue ['.' "length" '(' ')' | '(' [Args] ')']
//            |  Literal
void Factor() :
{}
{
    Unop() Factor()
|
    <LPAREN> Expr() <RPAREN>
|
    Lvalue() [ <LPAREN> [ Args() ] <RPAREN>
    |
    <PERIOD> <LENGTH> <LPAREN> <RPAREN> ]
|
    Literal()
}

// Lvalue     -> ["this" "."] <ID> {"." <ID>} ["[" Expr "]"]
Exp Lvalue() :
{boolean isThis = false; Exp e = null; Id i; Token tkn; Field f = null;}
{
    [ <THIS> <PERIOD>{ isThis = true; } ] tkn=<ID> 
    { 
        if (isThis)
            f = new Field(new This(), new Id(tkn.toString());
        else
            i = new Id(tkn.toString());
    }
    ( LOOKAHEAD(2) <PERIOD> <ID>
    { 
        if (f == null)
            f = new Field(i, new Id(tkn.toString());
        else
            f = new Field(f, new Id(tkn.toString());
    }
        )* [ <LBRACKET> e = Expr() <RBRACKET> ]
        {
            if (e != null)
            {
                if (f != null)
                    return new ArrayElm(f, e);
                else return new ArrayElm(i, e);
            }
            else
            {
                if(f != null)
                    return f;
                else
                    return i;
            }
        }
}

// Literal    -> <INTVAL> | <FLOATVAL> | "true" | "false"
void Literal() :
{}
{
    <INTVAL>
|
    <REAL>
|
    <TRUE>
|
    <FALSE>
}

// Relop    -> "==" | "!=" | "<" | "<=" | ">" | ">="
void Relop() :
{}
{
    <EQUAL>
|
    <NOT_EQUAL>
|
    <LESS_THAN>
|
    <LESS_THAN_OR_EQUAL>
|
    <GREATER_THAN>
|
    <GREATER_THAN_OR_EQUAL>
}


// Unop       -> "-" | "!"
void Unop() :
{}
{
    <MINUS>
|
    <NOT>
}
